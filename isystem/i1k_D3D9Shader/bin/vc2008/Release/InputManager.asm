; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\Matt\Desktop\C++Projects\DemoScene\isystem\i1k_D3D9Shader\src\InputManager.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??1InputManager@@QAE@XZ				; InputManager::~InputManager
; Function compile flags: /Ogspy
; File c:\users\matt\desktop\c++projects\demoscene\isystem\i1k_d3d9shader\src\inputmanager.cpp
;	COMDAT ??1InputManager@@QAE@XZ
_TEXT	SEGMENT
??1InputManager@@QAE@XZ PROC				; InputManager::~InputManager, COMDAT
; _this$ = ecx

; 23   : {

	push	esi
	mov	esi, ecx

; 24   : 	//Release the keyboard
; 25   : 	if (keyboardDevice)

	cmp	DWORD PTR [esi+16], 0
	je	SHORT $LN3@InputManag

; 26   : 	{
; 27   : 		keyboardDevice->Unacquire();

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+32]

; 28   : 		keyboardDevice->Release();

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN3@InputManag:

; 29   : 	}
; 30   : 
; 31   : 	//Release the mouse
; 32   : 	if (mouseDevice)

	cmp	DWORD PTR [esi+20], 0
	je	SHORT $LN2@InputManag

; 33   : 	{
; 34   : 		mouseDevice->Unacquire();

	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+32]

; 35   : 		mouseDevice->Release();

	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN2@InputManag:

; 36   : 	}
; 37   : 
; 38   : 	//Release DirectInput
; 39   : 	if (diObject)

	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN1@InputManag

; 40   : 		diObject->Release();

	mov	esi, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [esi]
	push	esi
	call	DWORD PTR [eax+8]
$LN1@InputManag:
	pop	esi

; 41   : }

	ret	0
??1InputManager@@QAE@XZ ENDP				; InputManager::~InputManager
_TEXT	ENDS
PUBLIC	?HandleKeyboard@InputManager@@AAEXXZ		; InputManager::HandleKeyboard
EXTRN	_memset:PROC
; Function compile flags: /Ogspy
;	COMDAT ?HandleKeyboard@InputManager@@AAEXXZ
_TEXT	SEGMENT
?HandleKeyboard@InputManager@@AAEXXZ PROC		; InputManager::HandleKeyboard, COMDAT
; _this$ = ecx

; 63   : {

	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	ebx, ecx

; 64   : 	// Get the input's device state, and put the state in keys - zero first
; 65   : 	memcpy(prevKeys, keys, sizeof(keys));

	push	64					; 00000040H
	lea	ebp, DWORD PTR [ebx+24]
	pop	ecx
	lea	edi, DWORD PTR [ebx+280]
	mov	esi, ebp
	rep movsd

; 66   : 	memset(keys, 0, sizeof(keys));

	mov	esi, 256				; 00000100H
	push	esi
	push	0
	push	ebp
	call	_memset

; 67   : 	HRESULT hr = keyboardDevice->GetDeviceState(sizeof(keys), keys);

	mov	eax, DWORD PTR [ebx+16]
	mov	ecx, DWORD PTR [eax]
	add	esp, 12					; 0000000cH
	push	ebp
	push	esi
	push	eax
	call	DWORD PTR [ecx+36]

; 68   : 	if (FAILED(hr))

	test	eax, eax
	jge	SHORT $LN4@HandleKeyb

; 69   : 	{
; 70   : 		   // If input is lost then acquire and keep trying until we get it back 
; 71   : 		   hr=keyboardDevice->Acquire();

	mov	eax, DWORD PTR [ebx+16]
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+28]

; 72   : 		   while( hr == DIERR_INPUTLOST ) 

	mov	edi, -2147024866			; 8007001eH
	jmp	SHORT $LN9@HandleKeyb
$LL3@HandleKeyb:

; 73   : 		   {          
; 74   : 				 hr = keyboardDevice->Acquire();

	mov	eax, DWORD PTR [ebx+16]
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+28]
$LN9@HandleKeyb:

; 72   : 		   while( hr == DIERR_INPUTLOST ) 

	cmp	eax, edi
	je	SHORT $LL3@HandleKeyb

; 75   : 		   }
; 76   : 		   // Could be we failed for some other reason
; 77   : 		   if (FAILED(hr))

	test	eax, eax
	jl	SHORT $LN4@HandleKeyb

; 78   : 			 return;
; 79   : 		   // Now read the state again
; 80   : 		   keyboardDevice->GetDeviceState( sizeof(keys), keys );

	mov	ebx, DWORD PTR [ebx+16]
	mov	eax, DWORD PTR [ebx]
	push	ebp
	push	esi
	push	ebx
	call	DWORD PTR [eax+36]
$LN4@HandleKeyb:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 81   : 	}
; 82   : }

	ret	0
?HandleKeyboard@InputManager@@AAEXXZ ENDP		; InputManager::HandleKeyboard
_TEXT	ENDS
PUBLIC	?AcquireMousePos@InputManager@@AAEXXZ		; InputManager::AcquireMousePos
EXTRN	__imp__GetCursorPos@4:PROC
; Function compile flags: /Ogspy
;	COMDAT ?AcquireMousePos@InputManager@@AAEXXZ
_TEXT	SEGMENT
_mousePos$ = -8						; size = 8
?AcquireMousePos@InputManager@@AAEXXZ PROC		; InputManager::AcquireMousePos, COMDAT
; _this$ = ecx

; 112  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ecx
	push	esi

; 113  : 	tagPOINT mousePos;
; 114  : 	if(GetCursorPos(&mousePos))

	lea	eax, DWORD PTR _mousePos$[ebp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp__GetCursorPos@4
	xor	ecx, ecx
	test	eax, eax
	je	SHORT $LN2@AcquireMou

; 115  : 	{
; 116  : 		oldX = mousePos.x;

	mov	eax, DWORD PTR _mousePos$[ebp]
	mov	DWORD PTR [esi], eax

; 117  : 		oldY = mousePos.y;

	mov	eax, DWORD PTR _mousePos$[ebp+4]
	mov	DWORD PTR [esi+4], eax

; 118  : 	}
; 119  : 	else

	jmp	SHORT $LN1@AcquireMou
$LN2@AcquireMou:

; 120  : 	{
; 121  : 		oldX = 0; 

	mov	DWORD PTR [esi], ecx

; 122  : 		oldY = 0; 

	mov	DWORD PTR [esi+4], ecx
$LN1@AcquireMou:

; 123  : 	}
; 124  : 	oldZ = 0;

	mov	DWORD PTR [esi+8], ecx
	pop	esi

; 125  : }

	leave
	ret	0
?AcquireMousePos@InputManager@@AAEXXZ ENDP		; InputManager::AcquireMousePos
_TEXT	ENDS
PUBLIC	?GetRelativeMousePos@InputManager@@QAEXAAH0@Z	; InputManager::GetRelativeMousePos
; Function compile flags: /Ogspy
;	COMDAT ?GetRelativeMousePos@InputManager@@QAEXAAH0@Z
_TEXT	SEGMENT
_xPos$ = 8						; size = 4
_yPos$ = 12						; size = 4
?GetRelativeMousePos@InputManager@@QAEXAAH0@Z PROC	; InputManager::GetRelativeMousePos, COMDAT
; _this$ = ecx

; 129  : 	xPos = mouseState.lX;

	mov	eax, DWORD PTR [ecx+536]
	mov	edx, DWORD PTR _xPos$[esp-4]
	mov	DWORD PTR [edx], eax

; 130  : 	yPos = mouseState.lY;

	mov	eax, DWORD PTR [ecx+540]
	mov	ecx, DWORD PTR _yPos$[esp-4]
	mov	DWORD PTR [ecx], eax

; 131  : }

	ret	8
?GetRelativeMousePos@InputManager@@QAEXAAH0@Z ENDP	; InputManager::GetRelativeMousePos
_TEXT	ENDS
PUBLIC	?GetAbsoluteMousePos@InputManager@@QAEXAAH0@Z	; InputManager::GetAbsoluteMousePos
; Function compile flags: /Ogspy
;	COMDAT ?GetAbsoluteMousePos@InputManager@@QAEXAAH0@Z
_TEXT	SEGMENT
_xPos$ = 8						; size = 4
_yPos$ = 12						; size = 4
?GetAbsoluteMousePos@InputManager@@QAEXAAH0@Z PROC	; InputManager::GetAbsoluteMousePos, COMDAT
; _this$ = ecx

; 135  : 	xPos = oldX;

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _xPos$[esp-4]
	mov	DWORD PTR [edx], eax

; 136  : 	yPos = oldY;

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _yPos$[esp-4]
	mov	DWORD PTR [ecx], eax

; 137  : }

	ret	8
?GetAbsoluteMousePos@InputManager@@QAEXAAH0@Z ENDP	; InputManager::GetAbsoluteMousePos
_TEXT	ENDS
PUBLIC	?IsKeyDown@InputManager@@QAE_NH@Z		; InputManager::IsKeyDown
; Function compile flags: /Ogspy
;	COMDAT ?IsKeyDown@InputManager@@QAE_NH@Z
_TEXT	SEGMENT
_key$ = 8						; size = 4
?IsKeyDown@InputManager@@QAE_NH@Z PROC			; InputManager::IsKeyDown, COMDAT
; _this$ = ecx

; 141  : 	return ((keys[key] & 0x80) > 0);

	mov	eax, DWORD PTR _key$[esp-4]
	movzx	eax, BYTE PTR [eax+ecx+24]
	and	al, 128					; 00000080H
	xor	cl, cl
	cmp	cl, al
	sbb	eax, eax
	neg	eax

; 142  : }

	ret	4
?IsKeyDown@InputManager@@QAE_NH@Z ENDP			; InputManager::IsKeyDown
_TEXT	ENDS
PUBLIC	?IsKeyDownOnce@InputManager@@QAE_NH@Z		; InputManager::IsKeyDownOnce
; Function compile flags: /Ogspy
;	COMDAT ?IsKeyDownOnce@InputManager@@QAE_NH@Z
_TEXT	SEGMENT
_key$ = 8						; size = 4
?IsKeyDownOnce@InputManager@@QAE_NH@Z PROC		; InputManager::IsKeyDownOnce, COMDAT
; _this$ = ecx

; 146  : 	return (IsKeyDown(key) && !((prevKeys[key] & 0x80)>0));

	mov	eax, DWORD PTR _key$[esp-4]
	add	eax, ecx
	test	BYTE PTR [eax+24], 128			; 00000080H
	jbe	SHORT $LN3@IsKeyDownO
	test	BYTE PTR [eax+280], 128			; 00000080H
	ja	SHORT $LN3@IsKeyDownO
	xor	eax, eax
	inc	eax
	jmp	SHORT $LN4@IsKeyDownO
$LN3@IsKeyDownO:
	xor	eax, eax
$LN4@IsKeyDownO:

; 147  : }

	ret	4
?IsKeyDownOnce@InputManager@@QAE_NH@Z ENDP		; InputManager::IsKeyDownOnce
_TEXT	ENDS
PUBLIC	?IsMouseKeyDown@InputManager@@QAE_NH@Z		; InputManager::IsMouseKeyDown
; Function compile flags: /Ogspy
;	COMDAT ?IsMouseKeyDown@InputManager@@QAE_NH@Z
_TEXT	SEGMENT
_key$ = 8						; size = 4
?IsMouseKeyDown@InputManager@@QAE_NH@Z PROC		; InputManager::IsMouseKeyDown, COMDAT
; _this$ = ecx

; 151  : 	return ((mouseState.rgbButtons[key] & 0x80)>0);

	mov	eax, DWORD PTR _key$[esp-4]
	movzx	eax, BYTE PTR [eax+ecx+548]
	and	al, 128					; 00000080H
	xor	cl, cl
	cmp	cl, al
	sbb	eax, eax
	neg	eax

; 152  : }

	ret	4
?IsMouseKeyDown@InputManager@@QAE_NH@Z ENDP		; InputManager::IsMouseKeyDown
_TEXT	ENDS
PUBLIC	?IsMouseKeyDownOnce@InputManager@@QAE_NH@Z	; InputManager::IsMouseKeyDownOnce
; Function compile flags: /Ogspy
;	COMDAT ?IsMouseKeyDownOnce@InputManager@@QAE_NH@Z
_TEXT	SEGMENT
_key$ = 8						; size = 4
?IsMouseKeyDownOnce@InputManager@@QAE_NH@Z PROC		; InputManager::IsMouseKeyDownOnce, COMDAT
; _this$ = ecx

; 155  : {

	push	esi

; 156  : 	return (IsMouseKeyDown(key) && !((prevMouseState.rgbButtons[key] & 0x80) > 0));

	mov	esi, DWORD PTR _key$[esp]
	push	esi
	mov	edx, ecx
	call	?IsMouseKeyDown@InputManager@@QAE_NH@Z	; InputManager::IsMouseKeyDown
	test	al, al
	je	SHORT $LN3@IsMouseKey
	test	BYTE PTR [esi+edx+568], 128		; 00000080H
	ja	SHORT $LN3@IsMouseKey
	xor	eax, eax
	inc	eax
	jmp	SHORT $LN4@IsMouseKey
$LN3@IsMouseKey:
	xor	eax, eax
$LN4@IsMouseKey:
	pop	esi

; 157  : }

	ret	4
?IsMouseKeyDownOnce@InputManager@@QAE_NH@Z ENDP		; InputManager::IsMouseKeyDownOnce
_TEXT	ENDS
PUBLIC	?ResetDevice@InputManager@@QAEXXZ		; InputManager::ResetDevice
; Function compile flags: /Ogspy
;	COMDAT ?ResetDevice@InputManager@@QAEXXZ
_TEXT	SEGMENT
?ResetDevice@InputManager@@QAEXXZ PROC			; InputManager::ResetDevice, COMDAT
; _this$ = ecx

; 44   : {

	push	esi
	mov	esi, ecx

; 45   : 	keyboardDevice->Acquire();

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	push	edi
	push	eax
	call	DWORD PTR [ecx+28]

; 46   : 	memset(prevKeys, 0, sizeof(prevKeys));

	mov	edi, 256				; 00000100H
	push	edi
	lea	eax, DWORD PTR [esi+280]
	push	0
	push	eax
	call	_memset

; 47   : 	memset(keys, 0, sizeof(keys));

	push	edi
	lea	eax, DWORD PTR [esi+24]
	push	0
	push	eax
	call	_memset

; 48   : 
; 49   : 	mouseDevice->Acquire();

	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [eax]
	add	esp, 24					; 00000018H
	push	eax
	call	DWORD PTR [ecx+28]

; 50   : 	memset(&prevMouseState, 0, sizeof(DIMOUSESTATE2));

	xor	eax, eax
	lea	edi, DWORD PTR [esi+556]
	stosd
	stosd
	stosd
	stosd
	stosd

; 51   : 	memset(&mouseState, 0, sizeof(DIMOUSESTATE2));

	xor	eax, eax
	lea	edi, DWORD PTR [esi+536]
	stosd
	stosd
	stosd
	stosd
	stosd
	pop	edi

; 52   : 
; 53   : 	AcquireMousePos();

	mov	ecx, esi
	pop	esi
	jmp	?AcquireMousePos@InputManager@@AAEXXZ	; InputManager::AcquireMousePos
?ResetDevice@InputManager@@QAEXXZ ENDP			; InputManager::ResetDevice
_TEXT	ENDS
PUBLIC	?HandleMouse@InputManager@@AAEXXZ		; InputManager::HandleMouse
; Function compile flags: /Ogspy
;	COMDAT ?HandleMouse@InputManager@@AAEXXZ
_TEXT	SEGMENT
?HandleMouse@InputManager@@AAEXXZ PROC			; InputManager::HandleMouse, COMDAT
; _this$ = ecx

; 85   : {

	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	ebx, ecx

; 86   : 	memcpy(&prevMouseState, &mouseState, sizeof(DIMOUSESTATE2));

	push	5
	lea	ebp, DWORD PTR [ebx+536]
	pop	ecx

; 87   : 	memset(&mouseState, 0, sizeof(DIMOUSESTATE2));

	xor	eax, eax
	lea	edi, DWORD PTR [ebx+556]
	mov	esi, ebp
	rep movsd
	mov	edi, ebp
	stosd
	stosd
	stosd
	stosd

; 88   : 
; 89   : 	HRESULT hr = mouseDevice->GetDeviceState( sizeof(DIMOUSESTATE2), &mouseState );

	push	ebp
	stosd
	mov	eax, DWORD PTR [ebx+20]
	mov	ecx, DWORD PTR [eax]
	push	20					; 00000014H
	push	eax
	call	DWORD PTR [ecx+36]

; 90   : 	if (FAILED(hr))

	test	eax, eax
	jge	SHORT $LN4@HandleMous

; 91   : 	{
; 92   : 		   // If input is lost then acquire and keep trying until we get it back 
; 93   : 		   hr=mouseDevice->Acquire();

	mov	eax, DWORD PTR [ebx+20]
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+28]

; 94   : 		   while( hr == DIERR_INPUTLOST ) 

	mov	esi, -2147024866			; 8007001eH
	jmp	SHORT $LN9@HandleMous
$LL3@HandleMous:

; 95   : 		   {          
; 96   : 				 hr = mouseDevice->Acquire();

	mov	eax, DWORD PTR [ebx+20]
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+28]
$LN9@HandleMous:

; 94   : 		   while( hr == DIERR_INPUTLOST ) 

	cmp	eax, esi
	je	SHORT $LL3@HandleMous

; 97   : 		   }
; 98   : 		   // Could be we failed for some other reason
; 99   : 		   if (FAILED(hr))

	test	eax, eax
	jl	SHORT $LN5@HandleMous

; 100  : 			 return;
; 101  : 		   AcquireMousePos();

	mov	ecx, ebx
	call	?AcquireMousePos@InputManager@@AAEXXZ	; InputManager::AcquireMousePos

; 102  : 		   // Now read the state again
; 103  : 		   mouseDevice->GetDeviceState( sizeof(DIMOUSESTATE2), &mouseState );

	mov	eax, DWORD PTR [ebx+20]
	mov	ecx, DWORD PTR [eax]
	push	ebp
	push	20					; 00000014H
	push	eax
	call	DWORD PTR [ecx+36]
$LN4@HandleMous:

; 104  : 	}
; 105  : 
; 106  : 	oldX += mouseState.lX;

	mov	eax, DWORD PTR [ebp]
	add	DWORD PTR [ebx], eax

; 107  : 	oldY += mouseState.lY;

	mov	eax, DWORD PTR [ebx+540]
	add	DWORD PTR [ebx+4], eax

; 108  : 	oldZ += mouseState.lZ;

	mov	eax, DWORD PTR [ebx+544]
	add	DWORD PTR [ebx+8], eax
$LN5@HandleMous:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 109  : }

	ret	0
?HandleMouse@InputManager@@AAEXXZ ENDP			; InputManager::HandleMouse
_TEXT	ENDS
PUBLIC	??0InputManager@@QAE@PAUHINSTANCE__@@PAUHWND__@@@Z ; InputManager::InputManager
EXTRN	_c_dfDIMouse2:BYTE
EXTRN	_GUID_SysMouse:BYTE
EXTRN	_c_dfDIKeyboard:BYTE
EXTRN	_GUID_SysKeyboard:BYTE
EXTRN	_DirectInput8Create@20:PROC
EXTRN	_IID_IDirectInput8A:BYTE
; Function compile flags: /Ogspy
;	COMDAT ??0InputManager@@QAE@PAUHINSTANCE__@@PAUHWND__@@@Z
_TEXT	SEGMENT
_hinst$ = 8						; size = 4
_hwnd$ = 12						; size = 4
??0InputManager@@QAE@PAUHINSTANCE__@@PAUHWND__@@@Z PROC	; InputManager::InputManager, COMDAT
; _this$ = ecx

; 4    : {

	push	ebx
	push	esi
	push	edi

; 5    : 	HRESULT hr = DirectInput8Create(hinst, DIRECTINPUT_VERSION, 
; 6    :         IID_IDirectInput8, (void**)&diObject, NULL);

	push	0
	mov	esi, ecx
	lea	edi, DWORD PTR [esi+12]
	push	edi
	push	OFFSET _IID_IDirectInput8A
	push	2048					; 00000800H
	push	DWORD PTR _hinst$[esp+24]
	call	_DirectInput8Create@20

; 7    : 
; 8    : 	//Create the keyboard
; 9    : 	hr = diObject->CreateDevice(GUID_SysKeyboard, &keyboardDevice, NULL);

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax]
	push	0
	lea	ebx, DWORD PTR [esi+16]
	push	ebx
	push	OFFSET _GUID_SysKeyboard
	push	eax
	call	DWORD PTR [ecx+12]

; 10   : 	hr = keyboardDevice->SetDataFormat( &c_dfDIKeyboard );

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax]
	push	OFFSET _c_dfDIKeyboard
	push	eax
	call	DWORD PTR [ecx+44]

; 11   : 	hr = keyboardDevice->SetCooperativeLevel(hwnd, DISCL_FOREGROUND | DISCL_NONEXCLUSIVE);

	mov	ebx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ebx]
	push	6
	push	DWORD PTR _hwnd$[esp+12]
	push	ebx
	call	DWORD PTR [eax+52]

; 12   : 
; 13   : 	//Create the mouse
; 14   : 	hr = diObject->CreateDevice(GUID_SysMouse, &mouseDevice, NULL);

	mov	edi, DWORD PTR [edi]
	mov	eax, DWORD PTR [edi]
	push	0
	lea	ebx, DWORD PTR [esi+20]
	push	ebx
	push	OFFSET _GUID_SysMouse
	push	edi
	call	DWORD PTR [eax+12]

; 15   : 	hr = mouseDevice->SetDataFormat( &c_dfDIMouse2 );

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax]
	push	OFFSET _c_dfDIMouse2
	push	eax
	call	DWORD PTR [ecx+44]

; 16   : 	hr = mouseDevice->SetCooperativeLevel(hwnd, DISCL_FOREGROUND | DISCL_EXCLUSIVE);

	mov	ebx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ebx]
	push	5
	push	DWORD PTR _hwnd$[esp+12]
	push	ebx
	call	DWORD PTR [eax+52]

; 17   : 	
; 18   : 	//Acquire devices
; 19   : 	ResetDevice();

	mov	ecx, esi
	call	?ResetDevice@InputManager@@QAEXXZ	; InputManager::ResetDevice
	pop	edi

; 20   : }

	mov	eax, esi
	pop	esi
	pop	ebx
	ret	8
??0InputManager@@QAE@PAUHINSTANCE__@@PAUHWND__@@@Z ENDP	; InputManager::InputManager
_TEXT	ENDS
PUBLIC	?Update@InputManager@@QAEXXZ			; InputManager::Update
; Function compile flags: /Ogspy
;	COMDAT ?Update@InputManager@@QAEXXZ
_TEXT	SEGMENT
?Update@InputManager@@QAEXXZ PROC			; InputManager::Update, COMDAT
; _this$ = ecx

; 57   : {

	push	esi
	mov	esi, ecx

; 58   : 	HandleKeyboard();

	call	?HandleKeyboard@InputManager@@AAEXXZ	; InputManager::HandleKeyboard

; 59   : 	HandleMouse();

	mov	ecx, esi
	pop	esi
	jmp	?HandleMouse@InputManager@@AAEXXZ	; InputManager::HandleMouse
?Update@InputManager@@QAEXXZ ENDP			; InputManager::Update
_TEXT	ENDS
END
